//UPPER LIMIT OF STATES 
const M = 2     //pump states 
const J = 7     //demand states 
const H = 13     //tank states 
 
//SET STATES 
range PumpState = 0..M 		//pump states
range DemandState = 1..J 	//demand states
range TankState = 1..H 		//tank states
 
range DeltaTank = -2..2 	//range of tank state transitions
range DeltaPump = 0..2		//range of pump state transition
 
//INITIALIZE STATES 
const A1 = 1    //initial state of pump1 
const A2 = 0    //initial state of pump2
const B = 2     //initial demand          
const C = 3     //initial tank 
 
//Physical components
TANK = (start -> TANKRUN[C]), 
    TANKRUN[h:TankState] = (stop -> TANK 
		|getTankState[h] -> tick ->  
			    (incT[i:1..1] -> TANKRUN[h+i] 
        	    |decT[i:1..2] -> TANKRUN[h-i] 
        	    |noChangeT -> TANKRUN[h] 
        )). 
 
DEMAND = (start -> DEMANDRUN[B]),  
    DEMANDRUN[d:DemandState] = (stop -> DEMAND  
        |getDemandState[d] -> tick ->  
                 (demand[1] -> DEMANDRUN[1] 
                 |demand[2] -> DEMANDRUN[2] 
                 |demand[3] -> DEMANDRUN[3] 
                 |demand[4] -> DEMANDRUN[4] 
                 |demand[5] -> DEMANDRUN[5] 
                 |demand[6] -> DEMANDRUN[6] 
                 |demand[7] -> DEMANDRUN[7] 
        )). 
 
PUMP = (start -> PUMPRUN[A1][A2]),  
    PUMPRUN[p1:PumpState][p2:PumpState] = (stop -> PUMP 
        |getPumpState[p1][p2] -> tick ->   
                (pump2on -> PUMPRUN[p1][1] 
			    |pump2off -> PUMPRUN[p1][0] 
                |pump1on -> PUMPRUN[1][p2] 
				|pump1off -> PUMPRUN[0][p2] 
        )). 
 
TIME = (start -> TIMERUN),  
    TIMERUN = (stop -> TIME  
        |tick -> TIMERUN 
        ). 
 
//Sensors 
DEMANDSENSOR = (start -> DEMANDSENSORRUN),  
    DEMANDSENSORRUN = (stop -> DEMANDSENSOR  
                    |getDemandState[d:DemandState] -> tick -> demandchan.send[d] -> DEMANDSENSORRUN 
					).  
 
PUMPSENSOR = (start -> PUMPSENSORRUN),  
    PUMPSENSORRUN = (stop -> PUMPSENSOR 
                    |getPumpState[p1:PumpState][p2:PumpState] -> tick ->  pumpchan.send[p1][p2] -> PUMPSENSORRUN 
					).  
 
TANKSENSOR = (start -> TANKSENSORRUN), 
    TANKSENSORRUN = (stop -> TANKSENSOR 
                    |getTankState[h:TankState] -> tick ->  tankchan.send[ho:TankState] -> TANKSENSORRUN 
					).  

//System control 
SYSCONTROL = (start -> SYSCONTROLRUN[A1][A2][B][C]),  
    SYSCONTROLRUN[pi1:PumpState][pi2:PumpState][di:DemandState][hi:TankState] =  
        (stop -> SYSCONTROL 
        |tick -> pumpchan.receive[p1:PumpState][p2:PumpState] -> tankchan.receive[h:TankState] -> demandchan.receive[d:DemandState] -> HC[p1][p2][d][h]), 
        HC[p1:PumpState][p2:PumpState][d:DemandState][h:TankState] =  
            (when(p1+p2==0 && d>=1 && d<=4) decT[1] -> DC[p1][p2][d][h]
            |when(p1+p2==0 && d>=5) decT[2] -> DC[p1][p2][d][h]
            |when(p1+p2==1 && d>=1 && d<=4) noChangeT -> DC[p1][p2][d][h]
            |when(p1+p2==1 && d>=5) decT[1] -> DC[p1][p2][d][h]
            |when(p1+p2==2 && d>=1 && d<=2) incT[1] -> DC[p1][p2][d][h]
            |when(p1+p2==2 && d==3 && h<=7) incT[1] -> DC[p1][p2][d][h]
            |when(p1+p2==2 && d==3 && h>=8) noChangeT -> DC[p1][p2][d][h]
            |when(p1+p2==2 && d>=4 && d<=6 && h>=1) noChangeT -> DC[p1][p2][d][h]
            |when(p1+p2==2 && d==7 && h>=1 && h<=5) noChangeT -> DC[p1][p2][d][h]           
            |when(p1+p2==2 && d==7 && h>=6) decT[1] -> DC[p1][p2][d][h]
        ),
          
         DC[p1:PumpState][p2:PumpState][d:DemandState][h:TankState] =  
                 (demand[1] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[2] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[3] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[4] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[5] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[6] -> SYSCONTROLRUN[p1][p2][d][h] 
                 |demand[7] -> SYSCONTROLRUN[p1][p2][d][h] 
        ). 
 
PUMPACTUATOR = (start -> PUMPACTUATORRUN), 
	PUMPACTUATORRUN = (stop -> PUMPACTUATOR  
		|tick -> pumpcontrollerchan.receive[o1:5..8] ->  
            (pump2on-> PUMPACTUATORRUN 
            |pump1on -> PUMPACTUATORRUN 
            |pump2off -> PUMPACTUATORRUN 
            |pump1off -> PUMPACTUATORRUN 
            ) 
	). 
   
//Cyber components 
PLC1 = (start -> PLC1RUN),  
	PLC1RUN = (stop -> PLC1 
		|tick -> tankchan.receive[h:TankState] -> plc1chan.send[h] -> plc2chan.receive[p1:PumpState][p2:PumpState] -> scadachan.send[p1][p2] -> PLC1RUN).  
 
PLC2 = (start -> PLC2RUN),  
    PLC2RUN = (stop -> PLC2  
        |tick -> pumpchan.receive[p1:PumpState][p2:PumpState] -> plc1chan.receive[h:TankState] -> plc2chan.send[p1][p2] ->    
            (when(h<=2) pumpcontrollerchan.send[5] -> PLC2RUN 
			|when(h>2 && h<=8) pumpcontrollerchan.send[6] -> PLC2RUN 
            |when(h>=9 && h<13) pumpcontrollerchan.send[7] -> PLC2RUN 
            |when(h>=13) pumpcontrollerchan.send[8] -> PLC2RUN 
			) 
	).  
 
SCADA = (start -> SCADARUN),  
	SCADARUN = (stop -> SCADA 
			|tick -> plc1chan.receive[h:TankState] -> scadachan.receive[p1:PumpState][p2:PumpState] -> display[h][p1][p2] -> SCADARUN).  
 
//DEMANDPAT = (start -> demand[2] -> demand[3] -> demand[1] -> demand[1] -> demand[2] -> stop -> DEMANDPAT).  

property SAFEPUMP1 = 
        //>6.3 pump one off 
        //>4.4 pump two off 
        //<4 pump one on  
        //<1 pump two on 
		(plc1chan.receive[h:TankState] ->
			(when(h<=2) pumpcontrollerchan.send[5] -> SAFEPUMP1 		//pump2on
			|when(h>2 && h<=8) pumpcontrollerchan.send[6] -> SAFEPUMP1  //pump1on
            |when(h>=9 && h<13) pumpcontrollerchan.send[7] -> SAFEPUMP1 //pump2off
            |when(h>=13) pumpcontrollerchan.send[8] -> SAFEPUMP1		//pump1off
			)
		).


property SAFEACTUATOR1 = 
	(pumpcontrollerchan.receive[o1:5..8] -> 
		(when(o1==5) pump2on-> PUMPACTUATORRUN 
        |when(o1==6) pump1on -> PUMPACTUATORRUN 
        |when(o1==7) pump2off -> PUMPACTUATORRUN 
        |when(o1==8) pump1off -> PUMPACTUATORRUN
		)
	). 

//fluent NOOVERFLOW[i:0..H] = <getTankState[i], incT[1]>
	
//assert FLOW1 = []!NOOVERFLOW[13]

//fluent NOUNDERFLOW[i:0..H][j:DeltaTank] = <getTankState[i], decT[j]>
	
//assert FLOW2 = []!NOUNDERFLOW[1][1]
//assert FLOW3 = []!NOUNDERFLOW[2][2]

//ATTACK = (tankchan.receive[h:TankState] ->  
//	(when(h==2) open.send[oh:TankState] -> ATTACK 
//	|when(h!=2) open.send[h] -> ATTACK)).  
 
||SYS = (TANK || TANKSENSOR || DEMAND || DEMANDSENSOR || PUMP || PUMPSENSOR || PUMPACTUATOR || TIME || SYSCONTROL || PLC1 || PLC2 || SCADA) 
	/{tankchan/tankchan.{send,receive}, demandchan/demandchan.{send, receive}, pumpchan/pumpchan.{send,receive},  
    pumpcontrollerchan/pumpcontrollerchan.{send,receive}, demandcontrollerchan/demandcontrollerchan.{send,receive},  
    tankcontrollerchan/tankcontrollerchan.{send,receive}, timechan/timechan.{send,receive},  
	plc1chan/plc1chan.{send,receive}, plc2chan/plc2chan.{send,receive}, scadachan/scadachan.{send, receive}, open/open.{send, receive}}>>{tick}.  
// maximal progress: lower the priority of tick (>>): eager physics 
 
||SYSSAFE = (SYS || SAFEPUMP1 || SAFEACTUATOR1) 
 /{tankchan/tankchan.{send,receive}, open/open.{send, receive}}.   
 
progress ScadaDisplay = {display.{[1][2], [2..3][1..2], [4][1], [5..6][0..1], [7][0]}} 
// SCADA should only be expected to display certain combinations of tank status and pump status given pump rules.  
